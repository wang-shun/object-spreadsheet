#!/usr/bin/env python
#
# This script merges any changes in the output of the CoffeeScript to TypeScript
# conversion (due to changes in the CoffeeScript files, the converter, or both)
# into the TypeScript files in src/, which may have been manually modified.  In
# support of this, the snapshot of the conversion output on which src/ is
# currently based is saved in tests/ts-generated.save/.  So the basic approach
# is:
#
# 1. Run the conversion with output to tests/ts-generated.new/.
# 2. Merge the differences from tests/ts-generated.save/ to
#    tests/ts-generated.new/ into src/.
# 3. Copy tests/ts-generated.new/ to tests/ts-generated.save/.
#
# Naturally, this script is idempotent.
#
# We do step 2 using git, because people working on this project are more likely
# to have a satisfactory configuration for git merges than to have (and like)
# any other tool we might pick.  The coupling between this script and the git
# version control of the working tree could be considered poor design, but it's
# also convenient in some ways.  We set up the merge using "git read-tree -m"
# because it has all the right safety checks, even though it's a little more
# work to prepare the input in the form of trees rather than an index.
# "git read-tree -m" is all-or-nothing, so it's convenient to do steps 2 and 3
# in a single command to help prevent failures from leaving the directories in
# an inconsistent state.  This means:
#
# - The initial state of src/ and tests/ts-generated.save/ is read from the
#   index, and the result of the merge is placed in the index, ready to be
#   committed.
# - If the working tree has unstaged changes to any of the affected files, this
#   script will fail without making any changes.
# - If the index contains any unmerged files, even ones completely unrelated to
#   the conversion, this script will fail without making any changes.  This is
#   unfortunate but not expected to be a common enough problem in practice to
#   prefer a different approach.
# - To undo a merging pass, you have to undo the changes to _both_ src/ and
#   tests/ts-generated.save/.  If you undo only the changes to src/ and keep the
#   changes to tests/ts-generated.save/, the script will consider that the
#   changes were successfully merged but you manually reversed them, and it will
#   not merge them again.
#
# Can I (Matt) really be the first one to think of this approach?  I didn't have
# any luck finding prior art on the web, but I'm not sure what terms to search
# for.

import errno
import os
import subprocess
import sys

# Don't make a total mess if someone runs this from a subdirectory.
os.chdir(os.path.dirname(sys.argv[0]))

# No arguments accepted.
assert len(sys.argv) == 1

pfx_input = 'tests/src-coffeescript/'
pfx_live = 'src/'
pfx_tsg_save = 'tests/ts-generated.save/'
pfx_tsg_new = 'tests/ts-generated.new/'

def replace_prefix(pfx_old, pfx_new, path):
  assert path.startswith(pfx_old)
  return pfx_new + path[len(pfx_old):]

# Returns: list of (mode-hash-stage (unparsed), path).
def git_ls_files(*args):
  output = subprocess.check_output(('git', 'ls-files', '--stage') + args)
  # We don't need to manipulate the mode, hash, or stage fields (this script
  # only uses stage-0 entries), so just separate all of them from the path.
  return [tuple(l.split('\t')) for l in output.splitlines()]

def delete_if_exists(path):
  try:
    os.unlink(path)
  except OSError, e:
    if e.errno != errno.ENOENT:
      raise

class TemporaryIndexFile:
  def __enter__(self):
    self.path = 'index.tmp'
    os.environ['GIT_INDEX_FILE'] = self.path
  def __exit__(self, exc_type, exc_value, exc_traceback):
    delete_if_exists(self.path)
    del os.environ['GIT_INDEX_FILE']
    return False  # Re-raise exception, if any

def subprocess_check_input(cmd, input):
  p = subprocess.Popen(cmd, stdin=subprocess.PIPE)
  p.communicate(input)
  retcode = p.poll()
  if retcode:
    raise CalledProcessError(retcode, cmd)

def make_tree(ls):
  with TemporaryIndexFile():
    subprocess_check_input(
      ('git', 'update-index', '--index-info'),
      ''.join('\t'.join(e) + '\n' for e in ls))
    return subprocess.check_output(('git', 'write-tree')).rstrip()

# Our goal is to construct trees with content as shown at each path:
#
# Path:     pfx_tsg_save  pfx_live  other
# ---------------------------------------
# tree1     tsg_save      tsg_save
# tree2     tsg_save      live      other
# tree3     tsg_new       tsg_new
# ---------------------------------------
# merge     tsg_new       merged    other
#
# "git read-tree -m" appears to require that tree2 match the entire index.

# Since we have to include everything, don't bother with a temporary index.
tree2 = subprocess.check_output(('git', 'write-tree')).rstrip()

ls_tsg_save = git_ls_files(pfx_tsg_save)

ls_tree1 = []
for e in git_ls_files(pfx_tsg_save):
  ls_tree1.append(e)
  ls_tree1.append((e[0], replace_prefix(pfx_tsg_save, pfx_live, e[1])))
tree1 = make_tree(ls_tree1)

subprocess.check_call(('make', '-C', 'tests/coffeescript-to-typescript'))
subprocess.check_call(('rm', '-rf', pfx_tsg_new))
try:
  subprocess.check_call(
    ('tests/coffeescript-to-typescript/bin/coffee',
     '-cma', '--namespace', 'Objsheets', '-o', pfx_tsg_new, pfx_input))
  with TemporaryIndexFile():
    subprocess.check_call(('git', 'add', pfx_tsg_new))
    ls_tsg_new = git_ls_files()
finally:
  subprocess.check_call(('rm', '-rf', pfx_tsg_new))

ls_tree3 = []
for e in ls_tsg_new:
  for pfx in pfx_tsg_save, pfx_live:
    ls_tree3.append((e[0], replace_prefix(pfx_tsg_new, pfx, e[1])))
tree3 = make_tree(ls_tree3)

# Looks like the -u option checks out only the files that "git read-tree" is not
# leaving unmerged.  "git merge-index" will check out the rest of the files with
# either the textual merge result or the conflict markup.
subprocess.check_call(('git', 'read-tree', '-mu', tree1, tree2, tree3))
subprocess.call(('git', 'merge-index', '-o', 'git-merge-one-file', '-a'))
